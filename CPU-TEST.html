<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>üíÄ SigmaSkibidi Test üíÄ</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: radial-gradient(circle at center, #000 40%, #010101);
    height: 100%;
    overflow: hidden;
    user-select: none;
    font-family: monospace;
  }

  h1 {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    font-size: 20px;
    letter-spacing: 2px;
  }

  #fps {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: #0f0;
    background: rgba(0, 0, 0, 0.5);
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 14px;
  }

  #hint {
    position: fixed;
    bottom: 10px;
    left: 10px;
    color: #999;
    font-size: 14px;
  }

  canvas {
    display: block;
  }
</style>
</head>
<body>
<h1>üíÄ SigmaSkibidi Test üíÄ</h1>
<div id="fps">FPS: --</div>
<div id="hint">TƒÉng d·∫ßn ƒë·ªô lag theo th·ªùi gian ü•Ä</div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let W, H, t = 0;
let mouseX = 0, mouseY = 0, rotateX = 0, rotateY = 0;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

// T·∫°o d·ªØ li·ªáu ban ƒë·∫ßu (r·∫•t nhi·ªÅu tia s√°ng)
let lineCount = 50000;
let lines = [];

function generateLines(n) {
  lines = [];
  for (let i = 0; i < n; i++) {
    const theta = Math.random() * 2 * Math.PI;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 1;
    const len = Math.random() * 0.08 + 0.02;
    lines.push({
      x: r * Math.sin(phi) * Math.cos(theta),
      y: r * Math.sin(phi) * Math.sin(theta),
      z: r * Math.cos(phi),
      len,
      noise: Math.random() * 2 * Math.PI
    });
  }
}
generateLines(lineCount);

// T∆∞∆°ng t√°c chu·ªôt
document.addEventListener("mousemove", e => {
  mouseX = e.clientX / W - 0.5;
  mouseY = e.clientY / H - 0.5;
});
document.addEventListener("touchmove", e => {
  const t = e.touches[0];
  mouseX = t.clientX / W - 0.5;
  mouseY = t.clientY / H - 0.5;
});

function draw() {
  t += 0.03;
  rotateY += (mouseX * 4 - rotateY) * 0.05;
  rotateX += (mouseY * 4 - rotateX) * 0.05;

  // Motion blur n·∫∑ng
  ctx.fillStyle = "rgba(0,0,0,0.08)";
  ctx.fillRect(0, 0, W, H);

  const cx = W / 2;
  const cy = H / 2;
  const scale = Math.min(W, H) / 2.5;
  const hueBase = (t * 60) % 360;

  for (let l of lines) {
    const plasma = Math.sin(t * 3 + l.noise) * 0.3 + Math.cos(t + l.x * 5) * 0.2;
    let x = l.x * (1 + plasma);
    let y = l.y * (1 + plasma);
    let z = l.z * (1 + plasma);

    // Rotate X
    let y1 = y * Math.cos(rotateX) - z * Math.sin(rotateX);
    let z1 = y * Math.sin(rotateX) + z * Math.cos(rotateX);
    y = y1; z = z1;

    // Rotate Y
    let x1 = x * Math.cos(rotateY) + z * Math.sin(rotateY);
    let z2 = -x * Math.sin(rotateY) + z * Math.cos(rotateY);
    x = x1; z = z2;

    const depth = 1 / (1.3 + z2);
    const px = cx + x * scale * depth;
    const py = cy + y * scale * depth;

    const nx = cx + (x + l.x * l.len) * scale * depth;
    const ny = cy + (y + l.y * l.len) * scale * depth;

    const hue = (hueBase + z2 * 90 + plasma * 120) % 360;
    const brightness = 60 + z2 * 40;
    const alpha = depth * 0.9;

    ctx.strokeStyle = `hsla(${hue}, 100%, ${brightness}%, ${alpha})`;
    ctx.lineWidth = depth * 2;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(nx, ny);
    ctx.stroke();
  }

  // TƒÉng d·∫ßn ƒë·ªô n·∫∑ng theo th·ªùi gian (t·ª± th√™m tia m·ªõi)
  if (t % 5 < 0.03 && lineCount < 120000) {
    lineCount += 2000;
    generateLines(lineCount);
    console.log(`üî∫ Added lines: ${lineCount}`);
  }

  requestAnimationFrame(draw);
}
draw();

// FPS Counter
let lastTime = performance.now();
let frames = 0;
const fpsDisplay = document.getElementById("fps");
function fpsCount() {
  const now = performance.now();
  frames++;
  if (now - lastTime >= 1000) {
    fpsDisplay.textContent = `FPS: ${frames} | Lines: ${lineCount}`;
    frames = 0;
    lastTime = now;
  }
  requestAnimationFrame(fpsCount);
}
fpsCount();
</script>
</body>
</html>
